1. Conversion de bases.
1.1  Impression des entiers avec print
Question 1

>>> print("{:x}".format(313131))
4c72b
Imprime des nombres dans l'écriture hexadécimale

>>> print("{:o}".format(313131))
1143453
Imprime des nombres dans l'écriture octale.

>>> print("{:X}".format(313131))
4C72B
Imprime des nombres(et des lettres majuscules) dans l'écriture hexadécimale

N.B.
>>> print("{:b}".format(313131))
1001100011100101011

Imprime des nombres dans l'écriture binaire.

Question 2.

>>> bin(1331)
'0b10100110011'
>>> hex(1331)
'0x533'
>>> oct(1331)
'0o2463'

/python file functions.py/
def conv(n):
    """
    Converts a digit to binary.
    :param n: int
    :return: converted number
    """
    assert type(n) == int, 'enter a number'
    if type(n) is not int:
        raise AssertionError
    return bin(n)

1.2  Transformer un entier en un chiffre

Question 3.
Lorsque n est un entier compris entre 0 et 9, l'expression chr(ord('0') + 6) est égale à n.
Si n >= 10, cette expression retourne des lettres, des carateres spetiaux et des signes de ponctuation.

Question 4.
>>> chr(ord('7') + 10)
'A'
>>> chr(ord('7') + 15)
'F'

Question 5.

/python file functions.py/
def integer_to_digit(n):
    """
    Converts integer to digit number.
    :param n: int, number to convert between 0 and 15.
    :return: new number of letter
    :examples:
    >>> integer_to_digit(15)
    'F'
    >>> integer_to_digit(0)
    '0'
    """
    assert 0 <= n <= 15, 'enter numbers between 0 and 15 incl.'
    if 0 <= n <= 9:
        res = chr(ord('0') + n)
    elif n > 9:
        res = chr(ord('7') + n)
    else:
        raise AssertionError
    return res

1.3  Convertir un entier en une chaîne de caractères

def integer_to_string(n,b):
    """
    Converts a number to bin, oct or hex system.
    :param n: int, number to convert
    :param b: int, 2/8/16
    :return: converted number
    """
    assert b == 2 or b == 8 or b == 16, 'enter 2, 8 or 16'
    if b == 2:
        return bin(n)
    elif b == 8:
        return oct(n)
    elif b == 16:
        return hex(n)
    else:
        return AssertionError

Question 7.

2  Opérations logiques sur les entiers
2.1  Les opérateurs logiques sur les entiers en Python

Question 8.

>>> a = 2
>>> b = 3
>>> a & b
2
>>> a | b
3
>>> a ^ b
1
>>> ~ a
-3
>>> ~ b
-4
>>> a << b
16
>>> a >> b
0

Question 9.

x << y
Retours x avec les bits décalés vers la gauche par endroits y (et de nouveaux bits sur la main-côté droit sont des zéros). Ceci est la même que la multiplication par 2 x ** y.
x >> y
Retours x avec les bits décalés vers la droite par endroits y. Ceci est le même que divisant(//) par 2 x ** y.

Question 10.

def deux_puissance(n):
    """
    Returns 2**n.
    """
    return 1 << n

Question 11.

On peut utiliser "& : opération et bit à bit" pour vérifier si nombre est pair ou non.
Si nombre & 1 == 0 : le nombre est pair

Voilà la fonction pour tester si le nombre est pair ou impair.

def pair(number):
    assert isinstance(number, int), 'use numbers'
    if number & 1:
        print('impair')
    elif (number & 1) == 0:
        print('pair')
    else:
        raise AssertionError

2.2  Conversion en base 2

Question 12.

def integer_to_binary_str(s):
    return str(s) if s<=1 else integer_to_binary_str(s>>1) + str(s&1)

Question 13.

def binary_str_to_integer(b):
    return int(b,2)

Question 14.

def byte_to_binary(n):
    b = 2147483648;
    str=''
    while b > 0:
        z = n & b;
        if z == 0:
             str=str+'0'
        else:
             str=str+'1'
        b = b >> 1;
    print (str)

Question 15.

import struct
def float_to_bin(num):
    return bin(struct.unpack('!I', struct.pack('!f', num))[0])[2:].zfill(32)

Question 16.
